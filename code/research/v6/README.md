# Note to myslf about the files in this folder:

This `v6` version is derived from the `v4` version, not the `v5` version. Below I briefly describe the change from `v4` to `v5` to provide context for `v6`.

The key change in `v5` as opposed to `v4` was that upon splitting a region into two new subregions, the two new subregions could share points at the border where they were split. If we split region $R$ into subregions $R_1$ and $R_2$, then points very close to the border could be included in the region on the other side of the border. This seemed to lead to slightly better performance than `v4` (though not obviously so), but it also led to certain complications. For example, because a subregion could now "contain" points that were not actually within the subregion bounds, which would mess up percentile calculations and also count towards the subregion `n_max` budget. This required certain adjustments described in `v5/README.md`.

The key change in this `v6` version compared to the `v4` version is that now, any time a model for a subregion $R$ is fit via `km()` (except the very first model), we fictitously extend the region bounds for $R$ in all directions, just to determine which $x$ and $y$ points will be used when fitting the `km()` model. Here is a brief description. Suppose $R = \prod_{i = 1}^d (a_i, b_i]$. If we set $\epsilon = 0.01$ then we calculate the vector $\boldsymbol \epsilon = 0.01 (b_1 - a_1, \dots, b_d - a_d)$, so the entries of $\boldsymbol \epsilon$ are 1% of the respectively lengths or widths of $R$ in the $d$ dimensions. Then when it comes time to call `km()` to fit a model for $R$, we include all $x$ points lying within $R^+ \coloneqq \prod_{i = 1}^d [a_i - \boldsymbol \epsilon_i, b_i + \boldsymbol \epsilon_i]$, and the corresponding $y$ points. That is, we pretend-extend the bounds of $R$ by 1% in each direction (at each end), in order to include any additional points that might be very close to $R$.

The actual bounds of $R$, *i.e.* the bounds over which EI is optimized, are unchanged. Furthermore, the list of points "contained" within $R$ is unchanged. Thus we are essentially cheating slightly by possibly using nearby points when fitting the `km()` model, but not counting these towards the `n_max` budget of observations for the region.

Accomplishing this requires writing two new helper functions in `v6/bo_partition_helper_funcs.R`:

* `prep_epsilion_vec()` takes in $R$ and $\epsilon$ and returns $\boldsymbol \epsilon$
* `augment_points()` takes in all the $x$ points, associated function values $y$, $R$ and $\boldsymbol \epsilon$, and returns the subset of $x$ lying within $R^+$, and the associated subset of $y$.

Furthermore, some additional data had to be gathered and passed around between functions, such as records of all the observations $x$ and the associated objective function values $y$, and other functions had to be modified. For example, calls to `km()` within `explore_region()` and `split_and_fit()` had to be preceded by calls to `prep_epsilon_vec()` and `augment_points`, since the output of `augment_points()` was fed into `km()`.