# Note to myself about the files in this folder:

The main change in these files as opposed to those in `v4` is that now `prep_subregions()` will allow potential new subregions to share new points that are very close to the border between the subregions. This is implemented via the inclusion of a `point_share_tol` parameter that `prep_subregions()` takes.

Implementing this change causes some complications in other parts of the code, and so far I have seen only very slight evidence that `v5` can outperform `v4`---most of the time, it seems that there is no difference in performance between the two versions. Perhaps the most significant complication arising in `v5` is that allowing a subregion $R$ to "contain" points that are not actually in that subregion can completely ruin the calculation of possible split points in dimension $d$ within $R$. For example, if the bounds for $R$ are $[0, 0.5] \times [0, 1]$ and $R$ "contains" the points $\{ (0.25, 0.25), (0.5, 0.5), (0, 0.51), (0.5, 0.51) \}$, then erroneously including the latter two points when splitting on dimension $1$ will lead to a proposed $0.75$-percentile split at $x_1 = 0.51$, which is actually outside the region.

In order to correct for this, when splitting $R$ in dimension $d$, I compute the percentiles based only on points that are within the bounds of region $R$ *in dimension $d$*. Therefore, if $R$ also contained the point $(0.25, 1.01)$, I would permit this point when computing percentiles for splitting on dimension $1$, but not when computing percentiles for splitting on dimension $2$.

However, I think I ran into a complication when implementing this. Based on the printouts I make, it seems like region bounds and the coordinates of observations are not always stored to the same number of decimal places, and I think this might cause problems when computing which points are within the region bounds in dimension $d$. In order to work around this, within `split_and_fit()`, I round the relevant region bounds and coordinates of observations to 4 decimal places. I am not sure if this is necessary or whether there is a more elegant solution.

Based on some testing, I have some confdidence that `v5` is working as intended, but I am not absolutely sure, so I'm not ready to ditch `v4` just yet.

Regarding differences in performance between `v4` nd `v5`, I believe that allowing a new subregion to contain point(s) that it would otherwise not include, due to using `point_share_tol > 0`, can lead to significant differences in how the EI optimization for a new subregion proceeds at the end of `split_and_fit()`.  I *think* this is because the Gaussian process model for a subregion is different when it includes one or more extra points, hence the EI optimization (which relies on the Gaussian process model) can lead to a very different optimized value of EI, occurring at a very different point within the domain of the objective function. If this leads to performance benefits, I have not observed anything substantial.

If `point_share_tol` is set too high, then subregions "contain" many points that are not actually within their bounds, which probably leads to increased frequency of splitting because we bump up against the `n_max` limit more often. I am pretty sure this is a bad thing.

Note: Another change that I had to make to `v5` as opposed to `v4` is to augment my checks in `prep_subregions()`. In `v4`, `prep_subregions()` checks the *range* of points in a proposed subregion, on the given `split_dimension`. This is done using the `frange()` function. (I don't remember why I did this.) With `point_share_tol_param = 0`, this should be bounded above by the actual region width. However, with `point_share_tol_param > 0`, the range of points can exceed the actual region width, so I had to add a check of the actual region width after the check on the range of points. I am not sure whether it is necessary to have both checks---maybe I can just use the new check of the actual region width. I guess I will have to test more to see.